---
layout: post
title: bottleneck programming
---

inspired by TOC (theory of constraints) and tiago notes on assumptions under throughput of learning in ribbonfarm

programming like a human being simply means applying the five steps

you look for constraints
you choose the bottleneck
you refactor the code
now there is a new bottleneck

step 1: either the constraints you chose were correct or wrong
 or the list is incomplete
step 2: either the bottleneck is in the constraints you chose or it's not
step 3: refactoring the code is not within the scope of this blog
step 4: rinse and repeat

this means that for greatest efficacy, you want to reach step 3 with the obectively true bottleneck 


at step 4: you see 2 kinds of outcomes either improvement or non-improvements

if you see improvements, you know you have found the bottleneck. but you cannot be sure if you have solved it in the objectively best way.

e.g. you alleviate the bottleneck in a way that causes more problem in the long run.

if you see non-improvements, you may or may not have found the bottleneck. you may have found it but your refactor didn't really solve the issue.

this piece may be its own chain (another level of abstraction)

you may have to dive deeper and treat this supposed bottleneck as a standalone chain to find its own bottleneck.

or you haven't readlly found the bottleneck